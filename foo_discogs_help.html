<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"
 lang="en" dir="ltr">
<head>
  <title>foo_discogs Tag Formatting Syntax Reference</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <link rel="stylesheet" type="text/css" href="../../titleformat_help.css" />
</head>
<body>
<div class="dokuwiki export">
<div class="toc">
<div class="tocheader toctoggle" id="toc__header">Table of Contents</div>
<div id="toc__inside">

<ul class="toc">
<li class="clear">

<ul class="toc">
<li class="level2"><div class="li"><span class="li"><a href="#foo_discogs_tag_formatting_syntax_reference" class="toc">foo_discogs Tag Formatting Syntax Reference</a></span></div>
<ul class="toc">
<li class="level3"><div class="li"><span class="li"><a href="#tag_formatting_strings" class="toc">Tag formatting strings</a></span></div></li>
<li class="level3"><div class="li"><span class="li"><a href="#objects_and_fields" class="toc">Objects and fields</a></span></div></li>
<li class="level3"><div class="li"><span class="li"><a href="#fd_arrays" class="toc">Arrays</a></span></div></li>
<li class="level3"><div class="li"><span class="li"><a href="#fd_functions" class="toc">Functions</a></span></div></li>
<li class="level3"><div class="li"><span class="li"><a href="#fd_examples" class="toc">Examples</a></span></div></li>
<li class="level3"><div class="li"><span class="li"><a href="#fd_usages" class="toc">Internal Usages</a></span></div></li>
<li class="level3"><div class="li"><span class="li"><a href="#fd_help" class="toc">Additional Help</a></span></div></li>
</ul>
</li></ul>
</li></ul>
</div>
</div>



<h2><a name="foo_discogs_tag_formatting_syntax_reference" id="foo_discogs_tag_formatting_syntax_reference">foo_discogs Tag Formatting Syntax Reference</a></h2>
<div class="level2">
</div>

<h3><a name="tag_formatting_strings" id="tag_formatting_strings">Tag Formatting Strings</a></h3>

<div class="level3">
<p>
    New to foo_discogs 2.0, information from the Discogs database is now mapped to tags via user-defined tag formatting strings. The advantage of flexible  tag mappings over the old, hardcoded tags, is that users now have exact control over what tags they write and how they write them. Post-processing of the hardcoded tags generated by foo_discogs 1.0 using other components is now a thing of the past.
</p>

<p>
    Tag formatting strings are an extension of foobar2000 titleformatting strings. The general syntax is similar, but our extension is quite a bit more complicated. You ought to understand titleformatting syntax before attempting to understand our extended tag formatting syntax.
</p>

<p>
    The underlying data that tag formatting strings operate on is loaded from the Discogs Database for the release and tracks being tagged and accessed via variables provided internally by foo_discogs. We've aimed to expose as much information from the Discogs API as we can, and to expose information in a hierarchical, object-oriented manner. These data fields and how they are accessed are described in detail in the following section.
</p>

<p>
    The biggest complication that foo_discogs' tag formatting strings has over normal titleformatting strings is support for arrays. Users may wish to write multi-value tags, which requires an array of tag results for a single tag. Additionally, much information available from the Discogs database is provided in the form of an array of values rather than a single value. Any scripting language to effectively perform tag mappings needs to support arrays.
</p>

</div>


<h3><a name="objects_and_fields" id="objects_and_fields">Objects and Fields</a></h3>

<div class="level3">

<p>
    Key to tag formatting strings are the data that's loaded from the Discogs API and exposed via variables, or fields, for the scripts to operate on and ultimately write to tags. As with  titleformatting strings, fields are accessed by wrapping their name with in % symbols, eg. %RELEASE_TITLE%. The name of a field specifies which data it is retrieving from the data model.
</p>

<p>
    All exposed data attributes come from an "object" in the data model. All objects expose attributes, otherwise they would be useless. Many objects also expose sub-objects of their own. All tag formatting fields refer to attributes of an object, but they may be accessed through various paths of sub-objects. The following table lists the objects in the data model.
</p>

<table class="inline">
    <tr>
        <th> Object </th><th> Description </th>
    </tr>
    <tr>
        <td> RELEASE </td><td> A Discogs release. </td>
    </tr>
    <tr>
        <td> TRACK </td><td> A track from a Discogs release. </td>
    </tr>
    <tr>
        <td> DISC </td><td> A disc parsed from the tracklist of a Discogs release. </td>
    </tr>
    <tr>
        <td> ARTIST </td><td> A Discogs artist. </td>
    </tr>
    <tr>
        <td> MASTER_RELEASE </td><td> A Discogs master release. </td>
    </tr>
    <tr>
        <td> LABEL </td><td> A label or company associated with the release. </td>
    </tr>
    <tr>
        <td> SERIES </td><td> A series, a group of releases by theme. </td>
    </tr>
    <tr>
        <td> FORMAT </td><td> A release medium format description. </td>
    </tr>
    <tr>
        <td> CREDIT </td><td> An accreditation of an artist. </td>
    </tr>
    <tr>
        <td> IMAGE </td><td> A release or artist image. </td>
    </tr>
</table>

<p>
    These objects are arranged in a hierarchy. At the top-level, there are a handful of root objects in the hierarchy. All tag formatting fields must begin at one of these root objects. The following table lists the available root objects.
</p>

<table class="inline">
    <tr>
        <th> Root Object </th><th> Description </th>
    </tr>
    <tr>
        <td> RELEASE </td><td> The Discogs release selected via the find_release dialog. </td>
    </tr>
    <tr>
        <td> TRACK </td><td> The track from the Discogs release's tracklist that this file was matched with on the release dialog. </td>
    </tr>
    <tr>
        <td> DISC </td><td> The disc from the Discogs release's tracklist that this track belongs to. Parsed by foo_discogs from the Discogs tracklist. </td>
    </tr>
    <tr>
        <td> MASTER_RELEASE </td><td> The Discogs master release that this release belongs to, if applicable. </td>
    </tr>
    <tr>
        <td> ARTISTS </td><td> The artist(s) for the matched track, if applicable; otherwise, the artist(s) for the release. Technically, this is not a true root object, but a shortcut for the sub-objects TRACK_ARTISTS "or" RELEASE_ARTISTS (whichever is defined first).</td>
    </tr>
</table>

<p>
    Non-root objects can only be accessed as sub-objects via a parent object, ultimately stemming from a root object.
    The following table lists the sub-objects available for each object. The type of the sub-object should be obvious from its name.
</p>

<table class="inline">
    <tr>
        <th> Object </th><th> Sub-object </th><th> Type </th><th>Description</th>
    </tr>
    <tr>
        <td> RELEASE </td><td> ARTISTS </td><td> array </td><td> Artists for the release. </td>
    </tr>
    <tr>
        <td> RELEASE </td><td> LABELS </td><td> array </td><td> Labels for the release. </td>
    </tr>
    <tr>
        <td> RELEASE </td><td> SERIES </td><td> array </td><td> Seriess for the release, if applicable. </td>
    </tr>
    <tr>
        <td> RELEASE </td><td> DISCS </td><td> array </td><td> Discs for the release. Each CD, Record, Tape, etc, is parsed as a separate disc. </td>
    </tr>
    <tr>
        <td> RELEASE </td><td> TRACKS </td><td> array </td><td> All tracks for the release. </td>
    </tr>
    <tr>
        <td> RELEASE </td><td> FORMATS </td><td> array </td><td> Formats for the release. Will include the format for each disc, and may include some additional. </td>
    </tr>
    <tr>
        <td> RELEASE </td><td> CREDITS </td><td> array </td><td> Credits for the release, if available. These are release-level, non-track-specific credits only. </td>
    </tr>
    <tr>
        <td> RELEASE </td><td> IMAGES </td><td> array </td><td> Images for the release, if available. </td>
    </tr>
    <tr>
        <td> DISC </td><td> TRACKS </td><td> array </td><td> All tracks for the disc. </td>
    </tr>
    <tr>
        <td> DISC </td><td> FORMAT </td><td> single </td><td> Format of this particular disc. </td>
    </tr>
    <tr>
        <td> TRACK </td><td> ARTISTS </td><td> array </td><td> Artists for the track, if applicable. </td>
    </tr>
    <tr>
        <td> TRACK </td><td> CREDITS </td><td> array </td><td> Credits for the track. All track-specific credits are put here, even if they were entered at the release level. </td>
    </tr>
    <tr>
        <td> TRACK </td><td> HIDDEN_TRACKS </td><td> array </td><td> Tracks hidden within this track. Additional tracks within the same audio file are placed here. </td>
    </tr>
    <tr>
        <td> MASTER_RELEASE </td><td> ARTISTS </td><td> array </td><td> Artists for the master release. </td>
    </tr>
    <tr>
        <td> MASTER_RELEASE </td><td> DISCS </td><td> array </td><td> Discs for the master release. </td>
    </tr>
    <tr>
        <td> MASTER_RELEASE </td><td> TRACKS </td><td> array </td><td> All tracks for the master release. TODO: verify if parsed same as for release or not... </td>
    </tr>
    <tr>
        <td> CREDIT </td><td> ARTISTS </td><td> array </td><td> Artists for a credit. </td>
    </tr>
    <tr>
        <td> ARTIST </td><td> IMAGES </td><td> array </td><td> Images for the artist, if available. </td>
    </tr>
</table>

<p>
    Sub-objects are traversed by concatenating their name after the parent object and an underscore (_), eg. DISC_FORMAT. To reiterate, all fields must start at root objects. For some fields, you may need to descend multiple layers of sub-objects, eg. RELEASE_CREDITS_ARTISTS.
</p>

<p>
    Of course objects themselves, including sub-objects, are not the goal of fields. It is the data attributes of the objects that we are ultimately accessing by these fields, so any field name that terminated in an object or sub-object name (ie. %RELEASE%, %DISC_FORMAT%) would be incomplete and would not resolve to anything. Here are the data attributes exposed from each object.
</p>

<table class="inline">
    <tr>
        <th> Object </th><th> Attribute </th><th> Type </th><th>Description</th>
    </tr>
    <tr>
        <td> RELEASE </td><td> ID </td><td> string </td><td> Discogs release id for the release. </td>
    </tr>
    <tr>
        <td> RELEASE </td><td> TITLE </td><td> string </td><td> Title for the release. </td>
    </tr>
    <tr>
        <td> RELEASE </td><td> COUNTRY </td><td> string </td><td> Country for the release. </td>
    </tr>
    <tr>
        <td> RELEASE </td><td> DATE </td><td> string </td><td> Release date formatted as "Mmm YYYY". </td>
    </tr>
    <tr>
        <td> RELEASE </td><td> DATE_RAW </td><td> string </td><td> Raw, unformatted release date string. </td>
    </tr>
    <tr>
        <td> RELEASE </td><td> YEAR </td><td> string </td><td> Release year. </td>
    </tr>
    <tr>
        <td> RELEASE </td><td> MONTH </td><td> string </td><td> Release month, if available. </td>
    </tr>
    <tr>
        <td> RELEASE </td><td> DAY </td><td> string </td><td> Release day, if available. </td>
    </tr>
    <tr>
        <td> RELEASE </td><td> NOTES </td><td> string </td><td> Raw release notes paragraph. </td>
    </tr>
    <tr>
        <td> RELEASE </td><td> BARCODE </td><td> string </td><td> Release barcode, if available. </td>
    </tr>
    <tr>
        <td> RELEASE </td><td> WEIGHT </td><td> string </td><td> Estimated weight, if available. </td>
    </tr>
    <tr>
        <td> RELEASE </td><td> TOTAL_DISCS </td><td> string </td><td> Total number of discs. </td>
    </tr>
    <tr>
        <td> RELEASE </td><td> TOTAL_TRACKS </td><td> string </td><td> Total number of tracks. </td>
    </tr>
    <tr>
        <td> RELEASE </td><td> DISCOGS_USERS_HAVE </td><td> string </td><td> Number of Discogs users who "have" this release. </td>
    </tr>
    <tr>
        <td> RELEASE </td><td> DISCOGS_USERS_WANT </td><td> string </td><td> Number of Discogs users who "want" this release. </td>
    </tr>
    <tr>
        <td> RELEASE </td><td> DISCOGS_AVG_RATING </td><td> string </td><td> Average rating by Discogs members. </td>
    </tr>
    <tr>
        <td> RELEASE </td><td> DISCOGS_RATING_VOTES </td><td> string </td><td> Number of rating votes. </td>
    </tr>
    <tr>
        <td> RELEASE </td><td> DISCOGS_STATUS </td><td> string </td><td> Release status in Discogs database. </td>
    </tr>
    <tr>
        <td> RELEASE </td><td> DISCOGS_DATA_QUALITY </td><td> string </td><td> Release data quality in Discogs database. </td>
    </tr>
    <tr>
        <td> RELEASE </td><td> DISCOGS_SUBMITTED_BY </td><td> string </td><td> Name of Discogs user who submitted this release. </td>
    </tr>
    <tr>
        <td> RELEASE </td><td> GENRES </td><td> array </td><td> Genres entered for release. </td>
    </tr>
    <tr>
        <td> RELEASE </td><td> STYLES </td><td> array </td><td> Styles entered for release. </td>
    </tr>
    <tr>
        <td> RELEASE </td><td> VIDEOS </td><td> array </td><td> Video URLs entered for release. </td>
    </tr>
    <tr>
        <td> RELEASE </td><td> SEARCH_FORMATS </td><td> string </td><td> Release formats string returned by artist search results. </td>
    </tr>
    <tr>
        <td> RELEASE </td><td> SEARCH_LABELS </td><td> string </td><td> Release labels string returned by artist search results. </td>
    </tr>
    <tr>
        <td> RELEASE </td><td> SEARCH_CATNOS </td><td> string </td><td> Release catalog numbers string returned by artist search results. </td>
    </tr>
    <tr>
        <td> DISC </td><td> NUMBER </td><td> string </td><td> Sequential number of this disc on the release, starting at 1. </td>
    </tr>
    <tr>
        <td> DISC </td><td> TOTAL_TRACKS </td><td> string </td><td> Total number of tracks on this disc. </td>
    </tr>
    <tr>
        <td> TRACK </td><td> NUMBER </td><td> string </td><td> Sequential number of this track on the release, starting at 1. </td>
    </tr>
    <tr>
        <td> TRACK </td><td> DISC_TRACK_NUMBER </td><td> string </td><td> Sequential number of this track on the disc, starting at 1. </td>
    </tr>
    <tr>
        <td> TRACK </td><td> TITLE </td><td> string </td><td> Title of this track. </td>
    </tr>
    <tr>
        <td> TRACK </td><td> INDEXTRACK_TITLE </td><td> string </td><td> Title of Index track this track falls under, if applicable. </td>
    </tr>
    <tr>
        <td> TRACK </td><td> HEADING </td><td> string </td><td> Heading portion of this track's title, if applicable. </td>
    </tr>
    <tr>
        <td> TRACK </td><td> SUBTRACK_TITLE </td><td> string </td><td> Sub-track title portion of this track's title, if applicable. </td>
    </tr>
    <tr>
        <td> TRACK </td><td> DISCOGS_DURATION_RAW </td><td> string </td><td> Raw duration value entered for this track. If a subtrack, contains index track duration. </td>
    </tr>
    <tr>
        <td> TRACK </td><td> DISCOGS_DURATION_SECONDS </td><td> string </td><td> Duration in seconds entered for this track. If a subtrack, contains index track duration. </td>
    </tr>
    <tr>
        <td> TRACK </td><td> DISCOGS_INDEXTRACK_DURATION_RAW </td><td> string </td><td> Raw duration value entered for this subtrack, if applicable. </td>
    </tr>
    <tr>
        <td> TRACK </td><td> DISCOGS_INDEXTRACK_DURATION_SECONDS </td><td> string </td><td> Duration in seconds entered for this subtrack, if aplicable. </td>
    </tr>
    <tr>
        <td> TRACK </td><td> DISCOGS_TRACK_NUMBER </td><td> string </td><td> Track position exactly as entered on Discogs. </td>
    </tr>
    <tr>
        <td> TRACK </td><td> TOTAL_HIDDEN_TRACKS </td><td> string </td><td> Number of hidden tracks inside this track. </td>
    </tr>
    <tr>
        <td> ARTIST </td><td> ID </td><td> string </td><td> Artist's id in Discogs database. </td>
    </tr>
    <tr>
        <td> ARTIST </td><td> NAME </td><td> string </td><td> Artist's name. </td>
    </tr>
    <tr>
        <td> ARTIST </td><td> NAME_VARIATION </td><td> string </td><td> Artist's name variation used, if applicable. </td>
    </tr>
    <tr>
        <td> ARTIST </td><td> JOIN </td><td> string </td><td> Join conjunction linking artist with previous artist, if applicable. </td>
    </tr>
    <tr>
        <td> ARTIST </td><td> PROFILE </td><td> string </td><td> Artist's profile section. </td>
    </tr>
    <tr>
        <td> ARTIST </td><td> REAL_NAME </td><td> string </td><td> Artist's read name. </td>
    </tr>
    <tr>
        <td> ARTIST </td><td> URLS </td><td> array </td><td> Artist's associated URLs. </td>
    </tr>
    <tr>
        <td> ARTIST </td><td> ALIASES </td><td> array </td><td> Artist's aliases. </td>
    </tr>
    <tr>
        <td> ARTIST </td><td> GROUPS </td><td> array </td><td> Groups artist is a member of. </td>
    </tr>
    <tr>
        <td> ARTIST </td><td> ALL_NAME_VARIATIONS </td><td> array </td><td> Known artist name variations. </td>
    </tr>
    <tr>
        <td> ARTIST </td><td> MEMBERS </td><td> array </td><td> Artist group member names. </td>
    </tr>
    <tr>
        <td> MASTER_RELEASE </td><td> ID </td><td> string </td><td> Master release id in Discogs database. </td>
    </tr>
    <tr>
        <td> MASTER_RELEASE </td><td> TITLE </td><td> string </td><td> Master release title. </td>
    </tr>
    <tr>
        <td> MASTER_RELEASE </td><td> YEAR </td><td> string </td><td> Release year. </td>
    </tr>
    <tr>
        <td> MASTER_RELEASE </td><td> MAIN_RELEASE_ID </td><td> string </td><td> Release id of main release in master release. </td>
    </tr>
    <tr>
        <td> MASTER_RELEASE </td><td> DISCOGS_DATA_QUALITY </td><td> string </td><td> Data quality in Discogs database. </td>
    </tr>
    <tr>
        <td> MASTER_RELEASE </td><td> GENRES </td><td> array </td><td> Genres entered for master release. </td>
    </tr>
    <tr>
        <td> MASTER_RELEASE </td><td> STYLES </td><td> array </td><td> Styles entered for master release. </td>
    </tr>
    <tr>
        <td> MASTER_RELEASE </td><td> VIDEOS </td><td> string </td><td> Video URLs entered for master release. </td>
    </tr>
    <tr>
        <td> LABEL </td><td> ID </td><td> string </td><td> Label id in Discogs database. </td>
    </tr>
    <tr>
        <td> LABEL </td><td> NAME </td><td> string </td><td> Label name. </td>
    </tr>
    <tr>
        <td> LABEL </td><td> CATALOG_NUMBER </td><td> string </td><td> Catalog number of release on label. </td>
    </tr>
    <tr>
        <td> SERIES </td><td> ID </td><td> string </td><td> Series id in Discogs database. </td>
    </tr>
    <tr>
        <td> SERIES </td><td> NAME </td><td> string </td><td> Series name. </td>
    </tr>
    <tr>
        <td> SERIES </td><td> NUMBER </td><td> string </td><td> Item number in series. Not necessarily an actual number. </td>
    </tr>
    <tr>
        <td> FORMAT </td><td> QUANTITY </td><td> string </td><td> Quality of format. </td>
    </tr>
    <tr>
        <td> FORMAT </td><td> NAME </td><td> string </td><td> Name of format. </td>
    </tr>
    <tr>
        <td> FORMAT </td><td> DESCRIPTIONS </td><td> array </td><td> Descriptions appended to format. </td>
    </tr>
    <tr>
        <td> CREDIT </td><td> ROLES_RAW </td><td> string </td><td> Raw credit roles string from Discogs. </td>
    </tr>
    <tr>
        <td> CREDIT </td><td> ROLES </td><td> array </td><td> Parsed list of credit roles. </td>
    </tr>
    <tr>
        <td> CREDIT </td><td> SHORT_ROLES </td><td> array </td><td> Parsed list of credit roles without any extra role information in brackets. </td>
    </tr>
    <tr>
        <td> IMAGE </td><td> TYPE </td><td> string </td><td> Image type on discogs - primary or secondary. </td>
    </tr>
    <tr>
        <td> IMAGE </td><td> URL </td><td> string </td><td> Image URL. </td>
    </tr>
    <tr>
        <td> IMAGE </td><td> THUMBNAIL_URL </td><td> string </td><td> Image thumbnail (150px) URL. </td>
    </tr>
</table>

<p>
    As with sub-objects, attributes are accessed by concatenating their name to after an underscore (_), eg. %DISC_FORMAT_QUANTITY%. We now have a complete data field variable: it begins at a root object, terminates at an attribute, and is wrapped with the % symbol.
</p>

<p>
    Note: Some sub-objects, such as artist and labels, are not fully loaded from the release. In the past, foo_discogs v1 loaded these before writing tags, knowing in advance what fields were needed. In foo_discogs v2, these fields trigger additional loading from the Discogs API while writing tags. Hence, using fields like ARTISTS_PROFILE will result in additional loading and slower tag writing.
</p>

<p>
    Note: if fields are missing, undefined, or not applicable, they return empty strings (or arrays of empty strings).
</p>

<p>
    It's impossible to go further without finally discussing arrays. While arrays are the subject of the next section, we should first describe how they relate to fields. As shown in the above chart, fields can either return a string or an array of string values. Furthermore, sub-objects that are denoted as type "array" will wrap all of their attributes in an array. Therefore, if an array field is accessed via an array sub-object, or a string field via an array sub-object of an array sub-object, a nested array will be the return type. Only one root object, ARTISTS, is of array type.
</p>

<p>
    Fields that return arrays are written with triangular brackets placed around their name, eg. %&#60;ARTISTS_NAME&#62;%. Fields that return a nested array (an array within an array) require multiple layers of triangular brackets, eg. %&#60;&#60;RELEASE_DISCS_TRACKS_NAME&#62;&#62;%. This rule is enforced in tag formatting strings for the sake of clarity and explicitness. You should always understand what exactly is being returned from a data field. Otherwise, you won't know how to manipulate it or what is being written to the tag.
</p>

</div>


<h3><a name="fd_arrays" id="fd_arrays">Arrays</a></h3>

<div class="level3">

<p>
    To extend titleformatting scripting with arrays, we have encoded arrays inside strings using special, non-character bytes as markers. As a consequence, unfortunately, builtin titleformatting functions cannot be used on foo_discogs arrays, as they are not aware of our encoding, will likely cause corruption, and will almost certainly not work as intended. Instead, we have re-implemented most of the builtin functions with their name prefixed with "multi_" (because the default functions cannot be overwritten). They will be described in the section on functions.
</p>

<p>
    In the examples in this document, arrays will be denoted between square brackets, ie. [abc,def,ghi] is an array consisting of the elements "abc", "def", and "ghi". Because arrays can be nested arbitrarily, we need some terminology to talk about their dimensions.
</p>

<p>
    The "depth" of an array A, denoted as D in our discourse, speaks to level of nesting of arrays inside it. For example, [a,b,c] is an array of depth 1, [[x,y,z]] of depth 2, and [[[]]] of depth 3. An array of depth 0 is a simple string. An array of depth 2 contains sub-array(s) of depth 1. You'll notice that [[x],[y],[z]] is also an array of depth 2. Hence, depth alone is not enough to know the shape of an array.
</p>

<p>
    The "width" of an array is its length. For example, [a,b,c,d,e] has width 5. An array of depth 2's width is its immediate number of sub-arrays. For example, [[x,y,z]] has width 1 while [[x],[y],[z]] has width 3.
</p>

<p>
    The "shape" of an array generally refers to its depth, its width, and the width of each of its nested sub-arrays. We don't attempt to quantitatively define the shape of an array. We only discuss it because some operations (ie. functions) on arrays only make sense when the array conforms to a certain shape, and most operations on multiple arrays only make sense if the arrays are of compatible shape.
</p>

<p>
    To write a multi-value tag, the tag formatting string for that tag should resolve to an array. Each value in the array will be written as a value to the tag. Note: Empty strings are always ignored when writing to tags.
</p>

<p>
    Arrays are coerced into a simple string by joining their elements. There are two cases where foo_discogs implicitly joins arrays (using ", " as the delimiter; see function $join(A) described below). The first case is if a tag formatting string returns an array of depth > 1. The array will be coerced to depth 1 by joining its nested sub-arrays. The second case is when a field that returns an array is not accessed with triangular braces (eg. %ARTISTS_NAME% instead of %&#60;ARTISTS_NAME&#62;%).
</p>

<p>
    Note: The depth of arrays is issumed to be uniform. For example, an array cannot have one sub-array of depth 2 and another of depth 1.
</p>

</div>


<h3><a name="fd_functions" id="fd_functions">Functions</a></h3>

<div class="level3">

<p>
    The following special functions all deal with array operations. Most builtin titleformatting functions cannot be used on foo_discogs arrays. Hence, many of the builtin functions are reimplemented below, prefixed with "multi_".
</p>

<p>
    Most functions operating on arrays operate at a certain depth. When we say that a function operates at depth 0, we mean that it operates on the outermost nested array. At the opposite extreme, a function operating at depth D (where D is the depth of the array), is operating on the individual strings at the bottom of the nested arrays. A function operating at depth D-1 is operating on an array of depth 1. For example, given A = [[[a,b,c]]], an function operating at depth D-1 is operating on [a,b,c], a function operating at depth D on a, b, and c, and a function operating at depth 0 on [[[a,b,c]]] as a whole.
</p>

<table class="inline">
    <tr>
        <th> Syntax </th><th> Description </th><th> Examples </th>
    </tr>
    
    <tr>
        <td> 
            $split(s,d) </td><td> Splits string s into an array of parts around delimiter d. Returns an array of depth 1.
        </td>
        <td>
            $split('abcd,efg,hijk',',') => [abcd,efg,hijk]
         </td>
    </tr>
    <tr>
        <td> 
            $split(s) </td><td> Equivalent to $split(s,', ').
        </td>
        <td>
         </td>
    </tr>
    
    <tr>
        <td> 
            $join(A,B) </td><td> Joins array A using delimiter B. Operates at depth D-1 in A and depth D in B. Returns an array of depth D-1.
            B must be a compatible array of the same shape or smaller than A.
            <br>
            Note: $join removes and ignores empty strings from A, also skipping their delimiter in B.
        </td>
        <td>
            $join([aaa,bbb,ccc],123) => aaa123bbb123ccc123
            <br>
            $join([[aaa,bbb,ccc]],[111,222,333] => [aaa111bbb222ccc333]
         </td>
    </tr>
    <tr>
        <td> $join(A) </td><td> Equivalent to $join(A,', '). </td>
        <td> $join([duck,frog,lion]) => duck, frog, lion </td>
    </tr>
    
    <tr>
        <td> 
            $zip(A,X,...) </td><td> Concatenates strings in A at depth D with X, etc. Operates at depth D and returns an array of the same shape as A.
            X, etc, must be compatible arrays of the same shape or smaller than A.
            <br>
            Note: $zip does not concatenate to A where A is the empty string.
        </td>
        <td>
            $zip([aaa,,ccc],XXX,[1,2,3]) => [aaaXXX1,,cccXXX3]
         </td>
    </tr>
    
    <tr>
        <td> 
            $array(A,B,C,...) </td><td> Creates an array with elements A, B, C, ....
        </td>
        <td>
            $array(1,2,3,4,5) => [1,2,3,4,5]
         </td>
    </tr>
    
    <tr>
        <td> 
            $arrayn(A,N) </td><td> Creates an array with N sub-elements, A. N is option and defaults to 1.
        </td>
        <td>
            $arrayn(aa,3) => [aa,aa,aa]
         </td>
    </tr>
    
    <tr>
        <td> 
            $unique(A) </td><td> Removes non-unique elements from A. Operates at depth 0. Returns an array with depth D but possibly smaller width at depth 0.
        </td>
        <td>
            $unique([aa,bb,aa,cc,aa,dd]) => [aa,bb,cc,dd]
         </td>
    </tr>
    
    <tr>
        <td> 
            $flatten(A) </td><td> Flattens nested array A. Returns array of depth 1 containing all strings of A at depth D.
        </td>
        <td>
            $flatten([[[a,b]],[[c,d]]]) => [a,b,c,d]
         </td>
    </tr>
    
    <tr>
        <td> 
            $extend(A,X,...) </td><td> Adds elements of X, etc, to A. Operates at depth D-1. Returns array of depth D, possibly wider at depth D-1.
            Arrays X, etc, must depth D and the same width at 0 ≥ depth ≤ D-1.
        </td>
        <td>
            $extend([[a,b]],[[c,d]]) => [[a,b,c,d]]
         </td>
    </tr>
    
    <tr>
        <td> 
            $sextend(A,X,...) </td><td> Shallow version of $extend that operates at depth 0. Returns an array of depth D, possibly wider at depth 0.
            Arrays X, etc, must have depth D and the same width at 1 ≥ depth ≤ D.
        </td>
        <td>
            $sextend([[a,b]],[[c,d]]) => [[a,b],[c,d]]
         </td>
    </tr>
    
    <tr>
        <td> 
            $append(A,X,...) </td><td> Adds X, etc, to array A. If A is a simple string, A is treated as [A]. Operates at depth D-1 on A,
            depth D on X, etc. Returns an array of depth D, possibly wider a depth D-1.
            Arrays X, etc, must have depth D-1 and the same width at 0 ≥ depth ≤ D-2.
        </td>
        <td>
            $append(a,b,c) => [a,b,c]
            $append([[aa,ab]],[bb,bc]) => [[aa,ab,bb,bc]]
         </td>
    </tr>
    
    <tr>
        <td> 
            $sappend(A,X,...) </td><td> Shallow version of $append that operates at depth 0. Returns an array of depth D, possibly wider at depth 0.
            Arrays X, etc, must have depth D-1 and the same width at 0 ≥ depth ≤ D-2.
        </td>
        <td>
            $sappend(a,b,c) => [a,b,c]
            $sappend([[aa,ab]],[bb,bc]) => [[aa,ab],[bb,bc]]
         </td>
    </tr>
    
    <tr>
        <td> 
            $contains(A,Q) </td><td> Tests whether Q is contained in A. Operates at depth D-1 on both A and Q.
            Array Q must be of compatible shape at depth 0 ≥ depth ≤ D-1.
            Returns a boolean array of depth D, but of the width of Q at depth D.
        </td>
        <td>
            $contains([[aa,ab]],[aa,bb,ab,bb]) => [[1,,1,]]
         </td>
    </tr>
    
    <tr>
        <td> 
            $filter(A,Q) </td><td> Removes values in Q from A. Operates at depth D-1 on both A and Q, or depth D in Q if Q is a simple string.
            Returns an array of similar shape to A, but possibly less wide at depth D-1.
        </td>
        <td>
            $filter([[aa,ab]],aa) => [[ab]]
            $filter([[aa,ab]],[[ac,ab]]) => [[aa]]
         </td>
    </tr>
    
    <tr>
        <td> 
            $first(A) </td><td> Returns first element from array A. Operates at depth 0. Returns an array of depth D-1.
        </td>
        <td>
            $first([aa,bb,cc]) => aa
            $first([[aa,ab,ac],[ba,bb,bc]]) => [aa,ab,ac]
         </td>
    </tr>
    
    <tr>
        <td> 
            $last(A) </td><td> Returns last element from array A. Operates at depth 0. Returns an array of depth D-1.
        </td>
        <td>
            $last([aa,bb,cc]) => cc
            $last([[aa,ab,ac],[ba,bb,bc]]) => [ba,bb,bc]
         </td>
    </tr>
    
    <tr>
        <td> 
            $element(A,n) </td><td> Returns nth element from array A. Operates at depth 0. Returns an array of depth D-1.
            n must be an integer.
        </td>
        <td>
            $element([aa,bb,cc],2) => bb
         </td>
    </tr>
    
    <tr>
        <td> 
            $length(A) </td><td> Returns width of array A at depth 0, as a simple string.
        </td>
        <td>
            $length([[aa,ab,ac],[ba,bb,bc]]) => 2
         </td>
    </tr>
    
    <tr>
        <td> 
            $any(A) </td><td> Tests whether any elements of A at depth D-1 evaluate to true. Returns a boolean array of depth D-1.
        </td>
        <td>
            $any([[,,],[a,b,c],[a,,]]) => [,1,1]
         </td>
    </tr>
    
    <tr>
        <td> 
            $all(A) </td><td> Tests whether all elements of A at depth D-1 evaluate to true. Returns a boolean array of depth D-1.
        </td>
        <td>
            $all([[,,],[a,b,c],[a,,]]) => [,1,]
         </td>
    </tr>
    
    <tr>
        <td> 
            $sum(A) </td><td> Counts the number of all elements of A at depth D-1 that evaluate to true. Returns an array of depth D-1.
        </td>
        <td>
            $sum([[,,],[a,b,c],[a,,]]) => [,3,1]
         </td>
    </tr>
    
    <tr>
        <td> 
            $multi_replace(A,X,Y) </td><td> Replaces X with Y in A. Operates at depth D. Returns array of the same shape as A.
            X and Y must be compatible arrays of same shape or smaller than A.
        </td>
        <td>
            $multi_replace([[aa,ab,ac]],aa,[[xx,yy,zz]]) => [[xx,ab,ac]]
         </td>
    </tr>
    
    <tr>
        <td> 
            $multi_trim(A) </td><td> Trims whitespace from elements of A. Operates at depth D. Returns array of the same shape as A.
        </td>
        <td>
            $multi_trim([[ aa,ab ,a c, ]]) => [[aa,ab,a c,]]
         </td>
    </tr>
    
    <tr>
        <td> 
            $multi_strcmp(A,X) </td><td> Performs $strcmp() on an array. Operates at depth D. Returns array of the same shape as A.
            X must be a compatible array of same size or smaller than A.
        </td>
        <td>
            $multi_strcmp([[aa,ab,ac]],ab) => [[,1,]]
         </td>
    </tr>
    
    <tr>
        <td> 
            $multi_strstr(A,X) </td><td> Performs $strstr() on an array. Operates at depth D. Returns array of the same shape as A.
            X must be a compatible array of same size or smaller than A.
        </td>
        <td>
            $multi_strstr([[aab,aba,abc,aac]],b) => [[2,1,1,]]
         </td>
    </tr>
    
    <tr>
        <td> 
            $multi_pad(A,N), $multi_pad_right(A,N) </td><td> Pads elements of A with spaces up to N characters. Operates at depth D. Returns array of the same shape as A.
            N must be a compatible integer array of same size or smaller than A.
        </td>
        <td>
            $multi_pad([x,y,z],3) => [x  ,y  ,z  ]
         </td>
    </tr>
    
    <tr>
        <td> 
            $multi_wrap(A,S) </td><td> Wraps elements of A with string S. Operates at depth D. Returns array of the same shape as A.
            N must be a compatible integer array of same size or smaller than A.
        </td>
        <td>
            $multi_pad([x,y,z],3) => [x  ,y  ,z  ]
         </td>
    </tr>
    
    <tr>
        <td> 
            $multi_pad(A,N,X), $multi_pad_right(A,N,X) </td><td> Pads elements of A with with character X up to N characters. Operates at depth D. Returns array of the same shape as A.
            N and X must be a compatible arrays of same size or smaller than A. N must be an integer, X a character.
        </td>
        <td>
            $multi_pad_right([x,yz],[2,3],[a,b]) => [ax,ayz]
         </td>
    </tr>
    
    <tr>
        <td> $multi_cut(A,N) </td>
        <td> Array version of $cut(). Operates at depth D. Return an integer array of the same shape as A. </td>
        <td> </td>
    </tr>
    
    <tr>
        <td> 
            $multi_if(A,X,Y) </td><td> Performs $if() on an array A, returning X where A evaluates to true and Y where A evaluates to false.
            Operates at depth D. Returns an array of the same shape as A. X and Y must be compatible arrays of the same size or smaller than A.
        </td>
        <td>
            $multi_if([[,,],[a,b,c],[a,,]],[A,B,C],no) => [[no,no,no],[B,B,B],[C,no,no]]
         </td>
    </tr>
    
    <tr>
        <td> 
            $multi_if2(A,Y) </td><td> Performs $if2() on an array A. Same as $multi_if(A,A,Y).
        </td>
        <td>
            $multi_if2([,1,1,],no) => [no,1,1,no]
         </td>
    </tr>
    
    <tr>
        <td> 
            $multi_and(A,X,...) </td><td> Returns true where both A and X evaluate to true, false otherwise. Operates at depth D.
            Returns a boolean array of the same shape as A. X must be a compatible array of the same size or smaller than A.
        </td>
        <td>
            $multi_or([[,,],[a,b,c],[a,,]],no) => [[no,no,no],[a,b,c],[a,no,no]]
         </td>
    </tr>
    
    <tr>
        <td> 
            $multi_or(A,X,...) </td><td> Returns A where A evaluates to true, or X where it evaluates to true, or false. Operates at depth D.
            Returns an array of the same shape as A. X must be a compatible array of the same size or smaller than A.
        </td>
        <td>
            $multi_or([[,,],[a,b,c],[a,,]],no) => [[no,no,no],[a,b,c],[a,no,no]]
         </td>
    </tr>
    
    <tr>
        <td> 
            $multi_not(A) </td><td> Returns false where A evaluates to true and vice versa. Operates at depth D.
            Returns a boolean array of the same shape as A.
        </td>
        <td>
            $multi_not([[,,],[a,b,c],[a,,]],no) => [[1,1,1],[,,,],[,1,1]]
         </td>
    </tr>
    
    <tr>
        <td> $multi_len(A) </td>
        <td> Array version of $len(). Operates at depth D. Returns an integer array of the same shape as A. </td>
        <td> </td>
    </tr>
    
    <tr>
        <td> $multi_longest(A,B,...) </td>
        <td> Array version of $longest(). Operates at depth D. Returns an array of the same shape as A. </td>
        <td> </td>
    </tr>
    
    <tr>
        <td> $multi_longer(A,B), $multi_greater(A,B) </td>
        <td> Array versions of $longer() and $greater(). Operate at depth D. Return boolean arrays of the same shape as A. </td>
        <td> </td>
    </tr>
    
    <tr>
        <td> $multi_left(A,N), $multi_right(A,N) </td>
        <td> Array version sof $left() and $right. Operate at depth D. Return arrays of the same shape as A. </td>
        <td> </td>
    </tr>
    
    <tr>
        <td> 
            $multi_add(A,B,...), $multi_sub(A,B,...), $multi_mul(A,B,...), $multi_div(A,B), $multi_mod(A,B), $multi_min(A,B,...), $multi_max(A,B,...) </td><td> Array version of math functions. Operate at depth D.
        </td>
        <td>
         </td>
    </tr>
    
    <tr>
        <td> 
            $multi_meta(N) </td><td> Array version of $meta(). Loads values of tag named N into an array of depth 1.
        </td>
        <td>
            $multi_meta(nonexistent_tag) => []
            $multi_meta(existent_tag) => [value1,value2,value3]
         </td>
    </tr>
    
    <tr>
        <td> 
            $multi_meta_files(N) </td><td> An array of $multi_meta() results for each release file being tagged. Returns an array of depth 2.
        </td>
        <td>
            $multi_meta_files(nonexistent_tag) => [[],[],[]]
            $multi_meta_files(existent_tag) => [[fileA_value1],[fileB_value1,fileB_value2],[]]
         </td>
    </tr>
    
    <tr>
        <td> 
            $pput(N,V), $pputs(N,V), $pget(N) </td><td> Similar to $put(), $puts(), and $get(), but persist across all tag formatting strings for a single file.
            <br>
            Note: If used, these functions create a dependency on the order in which tags are defined.
        </td>
        <td>
            $pput(temp,[1,2,3]) => [1,2,3]
            $pputs(temp,[1,2,3]) => ''
            $pget(temp) => [1,2,3]
         </td>
    </tr>
    
    <tr>
        <td> 
            $prompt(N) </td><td> Prompt user for value when generating tags.
        </td>
        <td>
            $prompt(temp) => value
         </td>
    </tr>
        
</table>

<p>
    Note: $multi_if and other boolean functions are slightly different than their builtin counterparts. The builtin functions are based on a truth value that is not accessible to custom functions, so the custom functions instead treat an empty string as false and anything else as true. Hence, something like $if(%MISSINGTAG%) is false while $multi_if(%MISSINGTAG%) is true, because %MISSINGTAG% returns "?". However, $multi_if($meta(MISSINGTAG)) will be false. Also, $if(X) is false where X is any number or character string, whereas $multi_if() will be true in this case.
</p>

<p>
    All builtin titleformatting functions can be used on arrays of depth 0, or simple strings, the builtin functions that generate strings can still be used to generate strings, and the variable operations (ie. $put and $get) can be used to store and retrieve arrays, since they don't modify their arguments.
</p>

</div>


<h3><a name="fd_examples" id="fd_examples">Examples</a></h3>

<div class="level3">

<p>
    Finally, let's look at some examples of tag formatting strings, including some changes likely to be popular with users.
</p>

1. Number tracks for the entire release, not starting at 1 for each disc:
<p>
    TRACKNUMBER = $num(%TRACK_NUMBER%,2)
</p>

2. Use master release date instead of release date, if applicable:
<p>
    DATE = $if2(%MASTER_RELEASE_YEAR%,%RELEASE_YEAR%)
</p>

3. Replace "Various" with "VA" in album artist:
<p>
    ALBUM ARTIST = $join($multi_replace(%&#60;RELEASE_ARTISTS_NAME&#62;%,'Various','VA'),$multi_wrap(%&#60;RELEASE_ARTISTS_JOIN&#62;%,' '))
</p>

4. Calculate percentage of track numbers from master release that exactly match track names from release:
<p>
    $puts(a,$multi_count($put(x,$contains(%&#60;RELEASE_TRACKS_TITLE&#62;%,%&#60;MASTER_RELEASE_TRACKS_TITLE&#62;%))))$puts(b,$multi_length($get(x)))$div($add($mul($get(a),100),$div($get(b),2)),$get(b))'%'
</p>

5. Approximate old COMPILATION tag (Discogs used to set album artist as "Various Artists" for all compilations; now they the name of any person written on the cover.):


<p>
    Refer to the default tag formatting strings in foo_discogs for additional examples.
</p>

</div>

<h3><a name="fd_usages" id="fd_usages">Internal Usages</a></h3>

<div class="level3">

<p>
    Within foo_discogs, tag formatting strings are used in several other contexts to allow users to customize parts of the interface.
</p>

<table class="inline">
    <tr>
        <th style="width:20%"> Usage </th><th> Description </th>
    </tr>
    
    <tr>
        <td> 
            Release formatting string
        </td>
        <td>
            In the releases list, all releases and master releases for the selected artist are shown, optionally filtered. Release entries in the list are formatted by this string.
            This formatting string has access to the respective RELEASE object and, if applicable, MASTER_RELEASE object. It should return a single string representing the release.
            <br><br>
            Note: Using fields not available from the Discogs search results will cause an additional API call for each release in the list which will be very slow. Not recommended.
            <br><br>
            Default: $if(%MASTER_RELEASE_ID%,'  '$ifequal(%RELEASE_ID%,%MASTER_RELEASE_MAIN_RELEASE_ID%,'* ','   '),)$join($append(%RELEASE_TITLE%,%RELEASE_SEARCH_LABELS%,%RELEASE_SEARCH_FORMATS%,%RELEASE_YEAR%,%RELEASE_SEARCH_CATNOS%))
        </td>
    </tr>
    
    <tr>
        <td> 
            Master formatting string
        </td>
        <td>
            In the releases list, all releases and master releases for the selected artist are shown, optionally filtered. Master release entries in the list are formatted by this string.
            This formatting string has access to the respective MASTER_RELEASE object. It should return a single string representing the master release.
            <br><br>
            Note: Using fields not available from the Discogs search results will cause an additional API call for each master release in the list which will be slow. Not recommended.
            <br><br>
            Default: '[master] '$join($append(%MASTER_RELEASE_TITLE%,%MASTER_RELEASE_YEAR%))
         </td>
    </tr>
    
    <tr>
        <td> 
            Tracklist Discogs formatting string
        </td>
        <td>
            In the left pane of the tracklist, Discogs tracks are shown. Entries in this list are formatted by this string. This formatting string has access to
            the RELEASE, DISC, and TRACK objects for the individual track. It should return a single string representing the track.
            <br><br>
            Default: $ifgreater(%RELEASE_TOTAL_DISCS%,1,%DISC_NUMBER%-,)$num(%TRACK_DISC_TRACK_NUMBER%,2) - $multi_if($multi_and(%ARTISTS_NAME_VARIATION%,$multi_not(%REPLACE_ANVS%)),%ARTISTS_NAME_VARIATION%$multi_if(%DISPLAY_ANVS%,*,),%ARTISTS_NAME%) - %TRACK_TITLE%$ifequal(%TRACK_TOTAL_HIDDEN_TRACKS%,0,,'   [+'%TRACK_TOTAL_HIDDEN_TRACKS%' HIDDEN]')
         </td>
    </tr>
    
    <tr>
        <td> 
            Tracklist file formatting string
        </td>
        <td>
            In the right pane of the tracklist, selected files are shown. Entries in this list are formatted by this string. This formatting string has access to the file info only.
            It should return a string representing the file.
            <br><br>
            Default: $if($strcmp($ext(%path%),tags),$info(@),%path%)
         </td>
    </tr>

    <tr>
        <td> 
            Album/artist art directory
        </td>
        <td>
            The directory that album or artist artwork is saved to is determined by these formatting strings.
            The formatting string has access to the relevant RELEASE or ARTIST object that the artwork is being saved for. Additionally, it has
            access to the IMAGE object for the image being saved. The formatting string should resolve to a single directory in which the artwork for the given release
            or artist will be saved. If the string resolves to "null", artwork will not be saved.
            <br><br>
            Default: $directory_path(%path%)
         </td>
    </tr>

    <tr>
        <td> 
            Album/artist art file prefix
        </td>
        <td>
            The file names that album or artist artword are saved as are determined by these formatting strings. The formatting string has access to the
            relevant RELEASE or ARTIST object that the artwork is being saved for. Additionally, it has access to the IMAGE object for the image being saved.
            A custom field %IMAGE_NUMBER% resolves to the sequential number of image being saved, in the case that fetch all available art is enabled and more
            than one image exists. The formatting string should resolve to a single file name for the given artist image. If the string resolves to "null",
            the image will be skipped.
            <br><br>
            Default: $directory_path(%path%)
         </td>
    </tr>

    <tr>
        <td>
            Artist IDs to download artwork for
        </td>
        <td>
            When saving artist artwork, the artist IDs that artwork is saved for are determined by this formatting string. The formatting string has access
            to the RELEASE and, if applicable, MASTER_RELEASE that artist artwork is being saved for. It should return an array of artist IDs.
            <br><br>
            Default: %&#60;RELEASE_ARTISTS_ID&#62;%
         </td>
    </tr>
    
    
</table>



</div>

<h3><a name="fd_help" id="fd_help">Additional Help</a></h3>

<div class="level3">
<p>
    For additional help or questions, try the <a href="http://www.hydrogenaud.io/forums/index.php?showtopic=50523">foo_discogs discussion thread on hydrogenaudio forums.</a>
</p>

</div>

<br><br><br>

</body>
</html>
